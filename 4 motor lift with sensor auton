#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Lift,           sensorPotentiometer)
#pragma config(Sensor, I2C_1,  Wheel,          sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port4,           rightWheel,    tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port5,           leftWheel,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightBot,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftTop,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rightTop,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftBot,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          claw,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!


void MoveClaw (int ClawPower);
void StopAll();
void LiftUp(int power);
void StartAuto();
void TurnLeft(int turnPower);
void GoStraight(int movePower);
void StopMove();
void TurnRight(int turnPower);
void ClearEncoder();
void MoveValue(int distance, int power);
void UpValue(int distance, int power);
void TurnValue(int distance, int power);


task Move();



/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	nMotorEncoder[rightWheel] = 0;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................

	StartAuto();
	//wait1Msec(1200);
	//MoveClaw(0);
	MoveValue(-600, 75);
	//StopMove();
	MoveClaw(100);
	wait1Msec(500);
	MoveClaw(40);
	UpValue(250,80);
	TurnValue(200, 50);
	MoveValue(740, 80);
	MoveClaw(-40);
	wait1Msec(500);
	MoveClaw(0);
	//LiftUp(80);
	//wait1Msec(2000);
	//LiftUp(30);
	//TurnRight(50);
	//wait1Msec(810);
	//StopMove();
	//GoStraight(80);
	//wait1Msec(1000);
	//StopMove();
	//MoveClaw(-80);
	//wait1Msec(1000);
	//MoveClaw(0);
	//GoStraight(-80);
	//wait1Msec(500);
	//MoveClaw(-80);
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	startTask (Move);

	while(true)
	{
		if (vexRT[Btn6U] == 1)
		{
			MoveClaw(100);
		}
		if (vexRT[Btn6D] == 1)
		{
			MoveClaw(-100);
			wait1Msec(10);
			MoveClaw(-20);
		}
		if (vexRT[Btn7U] == 1)
		{
			LiftUp(80);
			wait1Msec(10);
			LiftUp(40);
		}
		if (vexRT[Btn7D] == 1)
		{
			LiftUp(-80);
			wait1Msec(10);
			LiftUp(-20);
		}
		if (vexRT[Btn8L] == 1)
		{
			StopAll();
		}
	}
}



void LiftUp (int power)
{
	motor[leftTop] =	power;
	motor[leftBot] = power;
	motor[rightTop] = power;
	motor[rightBot] = power;

}
void MoveClaw (int ClawPower)
{
	motor[claw]= ClawPower;
}

void StopAll()
{
	motor[claw] = 0;

	motor[leftTop] =	0;
	motor[leftBot] = 0;
	motor[rightTop] = 0;
	motor[rightBot] = 0;
}

void StopMove()
{
	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
}

void StartAuto()
{
	MoveClaw(60);
	wait1Msec(400);
	MoveClaw(-100);
	wait1Msec(400);
	MoveClaw(-40);
}

void GoStraight(int movePower)
{
	motor[leftWheel] = -movePower;
	motor[rightWheel] = -movePower;
}
void TurnLeft(int turnPower)
{
	motor[leftWheel] = turnPower;
	motor[rightWheel] = -turnPower;
}

void TurnRight(int turnPower)
{
	motor[leftWheel] = -turnPower;
	motor[rightWheel] = turnPower;
}

void ClearEncoder() {
	nMotorEncoder[rightWheel] = 0;
}

void MoveValue(int distance, int power) {
	ClearEncoder();
	while (abs(nMotorEncoder[rightWheel])<abs(distance)){
		GoStraight(power);
	}
		GoStraight(0);
}

void UpValue(int distance, int power) {
	while (SensorValue(Lift)>distance){
		LiftUp(power);
	}
		LiftUp(0);
}
void TurnValue(int distance, int power) {
	ClearEncoder();
	while (abs(nMotorEncoder[rightWheel])<abs(distance)){
		TurnRight(power);
	}
		GoStraight(0);
}

task Move ()
{
	while (true)
	{
		motor[leftWheel] = -(vexRT[Ch3] + vexRT[Ch1]);
		motor[rightWheel] = -(vexRT[Ch3] - vexRT[Ch1]);

		EndTimeSlice();
	}
}
