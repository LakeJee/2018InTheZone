#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    GyroPosition,   sensorGyro)
#pragma config(Sensor, in7,    Lift,           sensorPotentiometer)
#pragma config(Sensor, in8,    ExternalBatteryValue, sensorAnalog)
#pragma config(Sensor, I2C_1,  Wheel,          sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           rightThird,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftThird,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightWheel,    tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port5,           leftWheel,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightBot,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftTop,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rightTop,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftBot,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          claw,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

int dist = 0;
int po = 0;
int time = 0;
int AdjustPowerUsingBatteryLevel(int originalPower);
//int AdjustPowerUsingExternalBatteryLevel(int originalPower);

void MoveClaw (int ClawPower);
void StopAll();
void LiftUp(int power);
void StartAuto();
//void TurnLeft(int turnPower);
void GoStraight(int movePower);
//void StopMove();
void TurnRight(int turnPower);
void ClearEncoder();
void MoveValue(int distance, int power);
void UpValue(int distance, int power);
void TurnValue(int distance, int power);
void DownValue(int distance, int power);
void TurnValueGyro(int distance, int power);
task TurnValueTask();
task MoveValueTask();
task Move();

// LCD AutonomousSelector
int globalDelay = 300;
int autonomousMode = 3;
void Autonomous1();
void Autonomous2();
void Autonomous3();
void ProgrammingSkill();
void AutonomousSelector(int btnLCD);
void DisplayAutonomousMode(int autonomousModeValue);
void displayBatteryLevelOnLCD(int autonomousModeValue);

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	nMotorEncoder[rightWheel] = 0;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	long startTime = nPgmTime;

	if (autonomousMode == 1)
	{
		Autonomous1();
	}
	else if (autonomousMode == 2)
	{
		Autonomous2();
	}
	else if (autonomousMode == 4)
	{
		ProgrammingSkill();
	}
	else
	{
		Autonomous3();
	}

	writeDebugStreamLine("autonomous) Time: %d", nPgmTime - startTime);
}

// .....................................................................................
// Autonomous 1: Knocks two stars on the left side of middle fence
// .....................................................................................
void Autonomous1()
{
	StartAuto(); //Opens out claw
	MoveValue(600, 75); //Moves to cube
	MoveClaw(100); //Grabs cube
	wait1Msec(500);
	MoveClaw(40); //Hold power
	UpValue(250, 80); //Raises Lift
	TurnValue(160, 50); //Rotates right
	MoveValue(740, 80); //Moves forward
	MoveClaw(-40); //Releases cube
	wait1Msec(500);
	MoveClaw(0);
	MoveValue(275, -50); //Moves back
	MoveClaw(-100); //Opens claw
	wait1Msec(1000);
	MoveClaw(-20); //maintains claw being open
	DownValue(350, -80); //lowers lift to be slightly above fence
	wait1Msec(600);
	MoveValue(250, 80); //move forward to knock more stars
	// MoveClaw(100); //close the claw
	wait1Msec(1000);
	MoveClaw(0);
}

// .....................................................................................
// Autonomous 2: Grabs three stars at the back side and then the cube
// .....................................................................................
void Autonomous2()
{
	StartAuto(); //Opens out claw
	MoveValue(568, 75); //Moves forward
	MoveClaw(100); //Grabs stars
	wait1Msec(500);
	MoveClaw(50); //Hold power
	UpValue(200, 80); //Lifts up
	TurnValue(175, -50); //Turns left
	wait1Msec(globalDelay);
	MoveValue(700, -85); //Moves back
	wait1Msec(1000);
	TurnValue(400, 50); //Turns right
	wait1Msec(globalDelay);
	LiftUp(40);//Hold power for lift
	MoveValue(675, 75); //Moves forward
	wait1Msec(500);
	LiftUp(0);
	MoveClaw(-100); //drops stars
	wait1Msec(500);
	// MoveClaw(50); // Closes claw
	MoveValue(350, -50); //Moves back
	MoveClaw(-100); //Opens claw
	wait1Msec(1000);
	MoveClaw(-20); //maintains claw being open
	DownValue(270, -80); //lowers lift to be slightly above fence
	wait1Msec(500);
	MoveValue(250, 80); //move forward to knock more stars
	// MoveClaw(100); //close the claw
	wait1Msec(1000);
	MoveClaw(0);
}

// .....................................................................................
// Autonomous 3 (Test): Grabs three stars at the back side and then the cube
// .....................................................................................
void Autonomous3()
{
	StartAuto(); //Opens out claw
	MoveValue(650, 127); //Moves forward
	MoveClaw(120); //Grabs stars
	wait1Msec(400);
	MoveClaw(50); //Hold power
	dist = 80;
	po = -127;
	time = 700;
	startTask (TurnValueTask); //Turns left
	UpValue(250, 127); //Lifts up
	MoveValue(450, -127); //Moves back
	//MoveClaw(50);//DELETE LATER
	wait1Msec(globalDelay);
	TurnValueGyro(710, 127); //Turns right
	wait1Msec(globalDelay);

	LiftUp(40);//Hold power for lift
	MoveValue(710, 127); //Moves forward and knocks stars over
	wait1Msec(globalDelay);
	LiftUp(0);
	MoveClaw(-120); //drops stars
	wait1Msec(globalDelay);
	MoveClaw(0);
	MoveValue(250, -127); //Go back
	wait1Msec(globalDelay);
	MoveClaw(-120); //Open claw a bit wider
	wait1Msec(100);
	MoveClaw(0);


	TurnValue(255, -127); //Turns Left to the cube

	dist = 40;
	po = -80;
	time = 0;

	startTask (MoveValueTask); //Go back

	// startTask (TurnValueTask); //Turn left to the cube
	wait1Msec(250);
	DownValue(2100, -80);
	wait1Msec(200);
	MoveValue(265, 75); //Move towards the cube
	wait1Msec(200);
	MoveClaw(100);
	MoveClaw(70);
	wait1Msec(200);
	dist = 80;
	po = 127;
	time = 400;
	startTask (TurnValueTask);
	UpValue(250, 127);
	wait1Msec(250);
	MoveValue(590, 127);//move forward to drop the cube
	wait1Msec(200);
	MoveClaw(-100);
	wait1Msec(500);
	MoveClaw(0);

	// .....................................................................................
	// Autonomous 3 (Test): Grabs three stars at the back side and then the cube
	// .....................................................................................

	/*
	StartAuto(); //Opens out claw
	wait1Msec(250);
	MoveValue(650, 127); //Moves forward
	MoveClaw(120); //Grabs stars
	wait1Msec(400);
	MoveClaw(50); //Hold power
	dist = 80;
	po = -127;
	time = 700;
	startTask (TurnValueTask); //Turns left
	UpValue(250, 127); //Lifts up
	MoveValue(800, -127); //Moves back
	//MoveClaw(50);//DELETE LATER
	wait1Msec(globalDelay);
	TurnValue(300, 127); //Turns right
	wait1Msec(globalDelay);
	LiftUp(40);//Hold power for lift
	MoveValue(620, 127); //Moves forward and knocks stars over
	wait1Msec(globalDelay);
	LiftUp(0);
	MoveClaw(-120); //drops stars
	wait1Msec(globalDelay);
	MoveClaw(0);
	MoveValue(300, -127); //Go back
	wait1Msec(globalDelay);
	MoveClaw(-120); //Open claw a bit wider
	wait1Msec(100);
	MoveClaw(0);
	dist = 255;
	po = -127;
	time = 0;
	startTask (TurnValueTask); //Turn left to the cube
	wait1Msec(250);
	DownValue(2100, -80);
	wait1Msec(200);
	MoveValue(265, 75); //Move towards the cube
	wait1Msec(200);
	MoveClaw(100);
	wait1Msec(100);
	MoveClaw(70);
	dist = 90;
	po = 127;
	time = 400;
	startTask (TurnValueTask);
	UpValue(250, 127);
	wait1Msec(200);
	MoveValue(590, 127);//move forward to drop the cube
	wait1Msec(200);
	MoveClaw(-100);
	wait1Msec(500);
	MoveClaw(0);
	*/
}

void ProgrammingSkill()
{
	StartAuto(); //Opens out claw
	wait1Msec(250);
	MoveValue(550, 75); //Moves forward
	MoveClaw(100); //Grabs stars
	wait1Msec(500);
	MoveClaw(50); //Hold power
	UpValue(200, 80); //Lifts up
	TurnValue(175, -50); //Turns left
	wait1Msec(globalDelay);
	MoveValue(550, -85); //Moves back
	wait1Msec(1000);
	TurnValue(375, 50); //Turns right
	wait1Msec(globalDelay);
	LiftUp(40);//Hold power for lift
	MoveValue(675, 75); //Moves forward
	wait1Msec(500);
	LiftUp(0);
	MoveClaw(-100); //drops stars
	wait1Msec(500);
	MoveClaw(0);
	MoveValue(300, -75); //Go back
	wait1Msec(globalDelay);
	MoveClaw(-100); //Open claw a bit wider
	wait1Msec(150);
	MoveClaw(0);
	TurnValue(325, -50); //Turn left
	wait1Msec(globalDelay);
	DownValue(2000, -80);
	wait1Msec(globalDelay);
	MoveValue(300, 75);
	wait1Msec(globalDelay);
	MoveClaw(100);
	wait1Msec(500);
	MoveClaw(50);
	UpValue(250, 80);
	wait1Msec(globalDelay);
	TurnValue(275, 50);
	wait1Msec(globalDelay);
	MoveValue(500, 75);
	wait1Msec(globalDelay);
	MoveClaw(-100);
	wait1Msec(500);
	MoveClaw(0);
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	startTask (Move);

	while(true)
	{
		// wait1Msec(50);

		int btnLCD = nLCDButtons;
		if (btnLCD > 0)
		{
			AutonomousSelector(btnLCD);
			// startTask(displayBatteryLevelOnLCD);
		}

		if (vexRT[Btn6U] == 1)
		{
			MoveClaw(100);
			wait1Msec(1);
			MoveClaw(20);
		}
		if (vexRT[Btn6D] == 1)
		{
			MoveClaw(-100);
			wait1Msec(10);
			MoveClaw(-5);
		}
		if (vexRT[Btn7U] == 1)
		{
			LiftUp(80);
			wait1Msec(10);
			LiftUp(40);
		}
		if (vexRT[Btn7D] == 1)
		{
			LiftUp(-80);
			wait1Msec(10);
			LiftUp(-20);
		}
		if (vexRT[Btn8L] == 1)
		{
			StopAll();
		}
	}
}

void AutonomousSelector(int btnLCD)
{
	writeDebugStreamLine("AutonomousSelector) button: %d", btnLCD);

	bLCDBacklight=true;

	displayBatteryLevelOnLCD(autonomousMode);
	int autonomousModeValue = autonomousMode;

	int button = 0;
	while(true)
	{
		button = nLCDButtons;

		if (button == 2 || vexRT[Btn8D] == 1)
		{
			displayBatteryLevelOnLCD(autonomousModeValue);

			bLCDBacklight=false;
			break;
		}
		else if (button == 1 || vexRT[Btn8L] == 1)
		{
			if (autonomousModeValue > 1)
			{
				autonomousModeValue--;
			}

			DisplayAutonomousMode(autonomousModeValue);
		}
		else if (button == 4 || vexRT[Btn8R] == 1)
		{
			if (autonomousModeValue < 6)
			{
				autonomousModeValue++;
			}

			DisplayAutonomousMode(autonomousModeValue);
		}
	}

	bLCDBacklight=false;
}

void DisplayAutonomousMode(int autonomousModeValue)
{
	writeDebugStreamLine("DisplayAutonomousMode) autonomousModeValue: %d", autonomousModeValue);

	clearLCDLine(0);                                            // Clear line 1 (0) of the LCD
	clearLCDLine(1);                                            // Clear line 2 (1) of the LCD

	string text;
	//}
	switch(autonomousModeValue)
	{
	case 1:
		{
			text = "Cube";
			break;
		}
	case 2:
		{
			text = "Stars";
			break;
		}
	case 3:
		{
			text = "Cube And Stars";
			break;
		}
	case 4:
		{
			text = "ProgrammingSkill";
			break;
		}
	}

	//Display the Primary Robot battery voltage
	// displayLCDString(0, 0, "Autonomous: ");
	displayLCDString(0, 0, text);

	wait1Msec(500);
}

void displayBatteryLevelOnLCD(int autonomousModeValue)
{
	writeDebugStreamLine("displayBatteryLevelOnLCD) autonomousModeValue: %d", autonomousModeValue);

	clearLCDLine(0);                                            // Clear line 1 (0) of the LCD
	clearLCDLine(1);                                            // Clear line 2 (1) of the LCD

	autonomousMode = autonomousModeValue;

	string text;
	sprintf(text, "Selected: %d", autonomousMode); //Build the value to be displayed

	//Display the Primary Robot battery voltage
	// displayLCDString(0, 0, "Autonomous: ");
	displayLCDString(0, 0, text);

	wait1Msec(800);

	//while(true)                                                        // An infinite loop to keep the program running until you terminate it
	//{
	clearLCDLine(0);                                            // Clear line 1 (0) of the LCD
	clearLCDLine(1);                                            // Clear line 2 (1) of the LCD

	string mainBattery, externalBattery;

	//Display the Primary Robot battery voltage
	displayLCDString(0, 0, "Primary: ");
	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
	displayNextLCDString(mainBattery);

	//float externalBatteryLevel = SensorValue[ExternalBatteryValue];
	//Display the Backup battery voltage
	displayLCDString(1, 0, "External: ");
	sprintf(externalBattery, "%1.2f%c", (SensorValue[ExternalBatteryValue] * 3.57)/1000.0, 'V');    //Build the value to be displayed
	displayNextLCDString(externalBattery);

	//Short delay for the LCD refresh rate
	wait1Msec(500);
}




void LiftUp (int power)
{
	motor[leftTop] =	power;
	motor[leftBot] = power;
	motor[rightTop] = power;
	motor[rightBot] = power;
	motor[leftThird]= power;
	motor[rightThird] = power;

}
void MoveClaw (int ClawPower)
{
	motor[claw]= ClawPower;
}

void StopAll()
{
	motor[claw] = 0;

	motor[leftTop] =	0;
	motor[leftBot] = 0;
	motor[rightTop] = 0;
	motor[rightBot] = 0;
	motor[rightThird] = 0;
	motor[leftThird] = 0;
}


//void StopMove()
//{
//	motor[leftWheel] = 0;
//	motor[rightWheel] = 0;
//}

void StartAuto()
{
	int open = -120;
	int delay = 350;
	if (autonomousMode == 3||autonomousMode == 2)
	{
		delay = 450;
	}
	else if (autonomousMode == 1)
	{
		open = -127;
		delay = 450;
	}

	MoveClaw(60);
	wait1Msec(400);
	MoveClaw(open);
	wait1Msec(delay);
	MoveClaw(0);
}

void GoStraight(int movePower)
{
	motor[leftWheel] = -movePower;
	motor[rightWheel] = -movePower;
}
//void TurnLeft(int turnPower)
//{
//	motor[leftWheel] = turnPower;
//	motor[rightWheel] = -turnPower;
//}

void TurnRight(int turnPower)
{
	motor[leftWheel] = -turnPower;
	motor[rightWheel] = turnPower;
}

void ClearEncoder() {
	nMotorEncoder[rightWheel] = 0;
}

void MoveValue(int distance, int power) {
	ClearEncoder();
	power = AdjustPowerUsingBatteryLevel(power);
	while (abs(nMotorEncoder[rightWheel])<abs(distance)){
		GoStraight(power);
	}
		GoStraight(0);
}

task MoveValueTask() {
	ClearEncoder();
	po = AdjustPowerUsingBatteryLevel(po);
	while (abs(nMotorEncoder[rightWheel])<abs(dist)){
		GoStraight(po);
	}
		GoStraight(0);
}


void UpValue(int distance, int power) {
		while (SensorValue(Lift)>distance){
		LiftUp(power);
		}
		LiftUp(0);
}
void DownValue(int distance, int power){
		while (SensorValue(Lift) < distance) {
		LiftUp(power);
		}
		LiftUp(0);
	}
void TurnValue(int distance, int power) {
	ClearEncoder();
	power = AdjustPowerUsingBatteryLevel(power);
	while (abs(nMotorEncoder[rightWheel])<abs(distance)){
		TurnRight(power);
	}
		GoStraight(0);
}

task TurnValueTask() {
	wait1Msec(time);
	ClearEncoder();
	po = AdjustPowerUsingBatteryLevel(po);
	while (abs(nMotorEncoder[rightWheel])<abs(dist)){
		TurnRight(po);
	}
		GoStraight(0);
}

void TurnValueGyro(int distance, int power) {
	// wait1Msec(time);
	SensorValue[GyroPosition] = 0;
	power = AdjustPowerUsingBatteryLevel(power);
	while (abs(SensorValue[GyroPosition])<abs(distance)){
		TurnRight(power);
	}
		GoStraight(0);
}

task Move ()
{
	while (true)
	{
		motor[leftWheel] = -(vexRT[Ch3] + vexRT[Ch1]);
		motor[rightWheel] = -(vexRT[Ch3] - vexRT[Ch1]);

		EndTimeSlice();
	}
}

int AdjustPowerUsingBatteryLevel(int originalPower)
{
	float batteryLevel = nImmediateBatteryLevel;
	float batteryOffset =	7150 / batteryLevel;
	int adjustedPower = originalPower * batteryOffset;
	//  writeDebugStreamLine("(AjustBattery) BatterLevel: %d - OriginalPower: %d - WantedPower: %d", AdjustBatteryLevel, OriginalPower, WantedPower);
	return adjustedPower;
}

/*
void GyroRotate(int power, int distance)
{
	int current = abs(SensorValue[GyroPosition]);
	float offset = 0;

	if (power == 0) return;

	power = AdjustPowerUsingBatteryLevel(power);

	//power = -power;
	while (current + offset < distance)
	{
		int previous = current;

		// RotateHelper(power);
		TurnRight(power);

		int current = abs(SensorValue[GyroPosition]);

		offset = current - previous;
		offset = offset * 1.6;
	}

	GoStraight();
}

void RotateHelper(int power)
{
	int adjustedPower = AdjustPowerUsingBatteryLevel(power) * -1;

	motor[FrontLeft] = -adjustedPower;
	motor[FrontRight] = -adjustedPower;
	motor[BackLeft] = adjustedPower;
	motor[BackRight] = adjustedPower;
}*/


/*int AdjustPowerUsingExternalBatteryLevel(int originalPower)
{
	float batteryLevel = SensorValue[ExternalBatteryValue] * 3.57;

	float batteryOffset =	7000 / batteryLevel;
	int adjustedPower = originalPower * batteryOffset;
	//  writeDebugStreamLine("(AjustBattery) BatterLevel: %d - OriginalPower: %d - WantedPower: %d", AdjustBatteryLevel, OriginalPower, WantedPower);
	return adjustedPower;
}*/
