#pragma config(Sensor, in1,    LiftPosition,   sensorPotentiometer)
#pragma config(Sensor, in2,    LeftClawPosition, sensorPotentiometer)
#pragma config(Sensor, in3,    RightClawPosition, sensorPotentiometer)
#pragma config(Sensor, in4,    ExternalBatteryValue, sensorAnalog)
#pragma config(Sensor, in5,    Accel_y,        sensorAccelerometer)
#pragma config(Sensor, in6,    GyroPosition,   sensorGyro)
#pragma config(Sensor, dgtl2,  LiftTouch,      sensorTouch)
#pragma config(Motor,  port1,           ClawLeft,      tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           WheelLeftOne,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           WheelLeftTwo,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           Lift_R1,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           Lift_R2,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           Lift_L1,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           Lift_L2,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           WheelRightOne, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           WheelRightTwo, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          ClawRight,     tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"




task StopAll();
task Move();
task ClawLeftControl();
task ClawRightControl();
task ClawLeftTask();
task ClawRightTask();
task Lift();
task Hang();


// Autonomous
void Autonomous_Accel();
void ProgrammingSkill();
void ProgrammingSkill_1();
void ProgrammingSkill_2();
void ProgrammingSkill_3();

void ThrowAuto(int delay);
void LiftUpAuto(int distance, int power);
void LiftDownAndStopAuto();
void MoveHelperAuto(int power, int delay);
void OpenClawAuto(int distance);
void CloseClawAuto();

void MoveHelper(int power);
void MoveValue(int distance, int power);
void MoveValue_Accel(int distance, int power);
void MoveForward(int distance, int power);
void MoveBackward(int distance, int power);

// User Controls
int AdjustPowerUsingBatteryLevel(int originalPower);
int AdjustPowerUsingExternalBatteryLevel(int originalPower);

void LiftHelper(int power);

void Turn(int power);
void TurnRight(int distance, int power);
void TurnLeft(int distance, int power);
void TurnValueGyro(int distance, int power);

void ClawHelper(int power);
void ClawHelperLeft(int power);
void ClawHelperRight(int power);

void Throw(int distanceLift, int distanceToThrow, int power);
void LiftDownAndStop(int distance, int power);
void LiftDownAndStop_Touch_DefaultTimeout(int power);
void LiftDownAndStop_Touch(int power, int timemout);

void LiftDown(int power);
void LiftUp(int power);
void LiftUpAndStop(int distance, int power);
void LiftUpNoStop(int distance, int power);
void LiftStop();

void OpenClaw(int power);
void CloseClaw(int power);
void StopClaw();
void DeployClaw();

void SetKnockDown();
void SetPositionHelper(bool increase, int targetLift, int targetLeftClaw, int targetRightClaw);
void SetPositionClawOnlyHelper(bool increase, int targetLeftClaw, int targetRightClaw);

const int MaxPower = 127;
bool ClawLeftWorking = false;
bool ClawRightWorking = false;

int autonomousMode = 1;
int globalWaiter = 200;
bool testMode = false;

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	bStopTasksBetweenModes = true;

	SensorValue[GyroPosition] = sensorNone;
	SensorValue[Accel_y] = sensorNone;
	wait1Msec(1000);

	SensorValue[GyroPosition] = sensorGyro;
	SensorType[Accel_y] = sensorAccelerometer;

	// SensorScale[GyroPosition] = 260;
	// SensorScale[GyroPosition] = 100;
	//Adjust SensorFullCount to set the "rollover" point. 3600 sets the rollover point to +/-3600
	SensorFullCount[GyroPosition] = 3600;

	SensorValue[GyroPosition] = 0;
	SensorValue[Accel_y] = 0;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	long startTime = nPgmTime;

	SensorValue[GyroPosition] = 0;

	// LockWheel(); // LockWheel should be in the pre_auto

	autonomousMode = 1;

	if (autonomousMode == 1)
	{
		Autonomous_Accel();
	}
	else if (autonomousMode == 2)
	{
		// Autonomous_IEM();
	}
	else if (autonomousMode == 3)
	{
		// Autonomous_2SL();
	}
	else if (autonomousMode == 4)
	{
		// Autonomous_2SR();
	}
	else if (autonomousMode == 5)
	{
		// ProgrammingSkill_Extended();
		ProgrammingSkill();
	}
	else if (autonomousMode == 6)
	{
		// Inspection();
	}
	else
	{
		// Autonomous_Accel();
	}

	writeDebugStreamLine("autonomous) Time: %d", nPgmTime - startTime);
}

void Autonomous_Accel() {
	DeployClaw();
	wait1Msec(500);
	LiftDownAndStopAuto();
	OpenClawAuto(1200);
	MoveForward(200, 100); //to cube
	CloseClawAuto(); //grab the cube
	LiftUpAuto(1600, 65); //hold lift up
	LiftUp(0);
	MoveForward(180, 60); //just a bit to align with stars
	wait1Msec(500);
	TurnLeft(700, 60); //rotate to fence
	MoveBackward(200, 60);
	Throw(3000 + 400, 2000 + 500, MaxPower);
	/*MoveForward(1500, 100); //to stars
	LiftDownAndStopAuto();
	CloseClawAuto();
	MoveBackward(200, 100); //a bit to not get stuck on wall
	LiftUpAuto(2000, 85); //hold lift up
	MoveBackward(1500, 100); //to the fence
	Throw(3000 + 400, 2000 + 500, MaxPower);*/
}

void ProgrammingSkill(){
	long startTime = nPgmTime;
	SetKnockDown();
	wait1Msec(globalWaiter);
	MoveForward(1900, 100); //move forward to the wall
	wait1Msec(globalWaiter * 3);
	MoveBackward(100, 70); //move backward to the wall
	wait1Msec(globalWaiter * 3);
	TurnLeft(1500, 60); //200 degree, 90 degrees is around 440
	LiftDownAndStopAuto();
	MoveForward(200, 70); //move forward to the wall to pick up
	writeDebugStreamLine("autonomous) KnockDown: %d", nPgmTime - startTime);
	ProgrammingSkill_1();
	writeDebugStreamLine("autonomous) ProgrammingSkill_1: %d", nPgmTime - startTime);
	wait1Msec(globalWaiter * 2);
	ProgrammingSkill_2();
	writeDebugStreamLine("autonomous) ProgrammingSkill_2: %d", nPgmTime - startTime);
	wait1Msec(globalWaiter * 2);
	ProgrammingSkill_3();
	writeDebugStreamLine("autonomous) Done: %d", nPgmTime - startTime);
}

void ProgrammingSkill_1(){
	long startTime = nPgmTime;
	int goBack = 0;

	for (int i = 0; i < 3; i++) {

		wait1Msec(1000);
		CloseClawAuto();

		int powerClaw = 5;

		if (i == 0) {
			powerClaw = 20;
		}

		CloseClaw(powerClaw);
		MoveBackward(50, 100); //move back from the wall
		LiftUpAuto(2000, 85);

		{	// Move Back
			goBack = 400;
			if (i == 0) {
				goBack = 1000;
			}

			MoveBackward(goBack, 100); //move back to fence to throw
		}

		ThrowAuto(globalWaiter);
		writeDebugStreamLine("autonomous) throw: %d, index: %d", nPgmTime - startTime, i);

		if (i < 2) {
			OpenClawAuto(1600);
			writeDebugStreamLine("ProgrammingSkill) OpenClaw, index:%d", i);
			MoveForward(200, 100); //move forward to wall to pick up
			writeDebugStreamLine("ProgrammingSkill) MoveForward, index:%d", i);
		}
	}
}

void ProgrammingSkill_2(){
	SetPositionHelper(false, 800, 400, 400);
	wait1Msec(globalWaiter);
	TurnRight(530, 60); //90 degrees is around 440
	writeDebugStreamLine("ProgrammingSkill) TurnRight");
	MoveBackward(10, 50); //move back from the wall
	writeDebugStreamLine("ProgrammingSkill) MoveBackward");
	LiftDownAndStopAuto();
	writeDebugStreamLine("ProgrammingSkill) LiftDown");
	wait1Msec(globalWaiter);
	MoveHelperAuto(70, 350);
	wait1Msec(globalWaiter * 3);
	SetPositionClawOnlyHelper(true, 800, 800);

	wait1Msec(globalWaiter  * 2);
	MoveForward(250, 70); //move back from the wall
	writeDebugStreamLine("ProgrammingSkill) MoveForward");
	CloseClawAuto();

	TurnLeft(200, 60); //90 degrees is around 440
	wait1Msec(globalWaiter);
	LiftUpAuto(2000, 85);
	TurnLeft(330, 60); //90 degrees is around 440
	wait1Msec(globalWaiter * 3);

	ThrowAuto(500); // throw three stars #1

	OpenClawAuto(1600);
	wait1Msec(globalWaiter);
	MoveHelper(30);
	wait1Msec(globalWaiter);
	CloseClawAuto();
	LiftUpAuto(2000, 85);

	ThrowAuto(globalWaiter * 3); // throw cube #1

	OpenClawAuto(1600);

	wait1Msec(globalWaiter);
	MoveForward(320, 100); //move forward to wall to pick up
	wait1Msec(globalWaiter);
	CloseClawAuto();

	MoveBackward(50, 100); //move back from the wall
	LiftUpAuto(2000, 85);
	MoveBackward(400, 100); //move back to fence to throw

	ThrowAuto(globalWaiter); // throw three stars #2
}

void ProgrammingSkill_3(){
	SetPositionHelper(false, 800, 400, 400);
	wait1Msec(globalWaiter);
	TurnRight(530, 60); //90 degrees is around 440
	writeDebugStreamLine("ProgrammingSkill) TurnRight");
	LiftDownAndStopAuto();
	writeDebugStreamLine("ProgrammingSkill) LiftDown");
	wait1Msec(globalWaiter);
	MoveForward(150, 70); //move back from the wall
	writeDebugStreamLine("ProgrammingSkill) MoveForward");
	SetPositionClawOnlyHelper(true, 1000, 1000);
	writeDebugStreamLine("ProgrammingSkill) SetPositionClawOnlyHelper");

	MoveForward(100, 70); //move back from the wall
	writeDebugStreamLine("ProgrammingSkill) MoveForward");
	CloseClawAuto();

	MoveHelperAuto(-50, globalWaiter * 2);
	wait1Msec(globalWaiter);
	TurnLeft(750, 60); //90 degrees is around 440
	wait1Msec(globalWaiter * 2);
	OpenClawAuto(2000);

	wait1Msec(globalWaiter);
	MoveForward(600, 100); //move forward to pick up star #1
	wait1Msec(globalWaiter);
	CloseClawAuto();

	CloseClaw(20);
	MoveBackward(60, 100); //move back from the wall
	LiftUpAuto(2000, 85);
	MoveBackward(450, 100); //move back to fence to throw

	ThrowAuto(globalWaiter); // throw two stars and cube
}

void ThrowAuto(int delay) {
	MoveHelperAuto(-20, delay);
	Throw(3000 + 400, 2000 + 500, MaxPower);
	wait1Msec(globalWaiter);
}

void LiftUpAuto(int distance, int power) {
	LiftUpAndStop(distance, power);
	LiftUp(20);
}

void LiftDownAndStopAuto() {
	LiftDownAndStop_Touch_DefaultTimeout(40);
	LiftDown(10);
}


void MoveHelperAuto(int power, int delay) {
	MoveHelper(power);
	wait1Msec(delay);
	MoveHelper(0);
}

void OpenClawAuto(int distance) {
	OpenClaw(MaxPower);
	waitUntil(SensorValue[LeftClawPosition] > distance || SensorValue[RightClawPosition] > distance);
	StopClaw();
}

void CloseClawAuto() {
	ClawLeftWorking = ClawRightWorking = true;
	CloseClaw(MaxPower);

	int pValue = 800;
	waitUntil((SensorValue[LeftClawPosition] < pValue || SensorValue[RightClawPosition] < pValue)
	|| (ClawLeftWorking == false || (ClawRightWorking == false)));


	wait1Msec(globalWaiter);

	CloseClaw(5);
}

void MoveHelper(int power)
{
	motor[WheelRightOne] = power;
	motor[WheelLeftOne] = power;
	motor[WheelRightTwo] = power;
	motor[WheelLeftTwo] = power;
}

void MoveForward(int distance, int power)
{
	MoveValue(distance, power);
}

void MoveBackward(int distance, int power)
{
	MoveValue(distance, -power);
}

void MoveValue(int distance, int power) {
	MoveValue_Accel(distance, power);
	// MoveValue_IEM(distance, power);
}

void MoveValue_Accel(int distance, int power) {
	// ClearEncoder();

	//writeDebugStreamLine("MoveValue_Accel) Started ===");
	//const float offset = 0.8;
	//float distance = distance_or * offset;

	int velocity = 0;
	int position = 0;
	int value = 0;
	clearTimer(T3);
	power = AdjustPowerUsingBatteryLevel(power);
	while (abs(position) < abs(distance)){
		value = SensorValue[Accel_y];
		velocity += value;
		//velocity = (value == 0)? velocity : velocity + value;
		position += velocity;

		// writeDebugStreamLine("MoveValue_Accel) pos: %d, dis: %d ", position, distance);
		if (time1[T3] >= 2000)
		{
			break;
		}
		MoveHelper(power);
		wait1Msec(100);
	}
	MoveHelper(0);
}


void TurnRight(int distance, int power) {
	TurnValueGyro (distance, power);
}

void TurnLeft(int distance, int power) {
	TurnValueGyro (distance, -power);
}

void TurnValueGyro(int distance, int power) {
	// wait1Msec(time);
	SensorValue[GyroPosition] = 0;
	power = AdjustPowerUsingBatteryLevel(power);
	while (abs(SensorValue[GyroPosition])<abs(distance)){
		Turn(power);
	}
	Turn(0);
}

void Turn(int power)
{
	motor[WheelRightOne] = -power
;	motor[WheelLeftOne] = power;
	motor[WheelRightTwo] = -power;
	motor[WheelLeftTwo] = power;
}



/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task StopAll()
{
	while (true)
	{
		wait1Msec(50);

		if (vexRT[Btn8L] == 1)
		{
			// Stops everything
			// int power = 0;
			LiftStop();
			StopClaw();
			//MoveHanging(power);
			//MoveClaw(power);
		}
	}
}


task Move()
{
	while (true)
	{
		wait1Msec(50);

		while(testMode == false) {

			motor[WheelRightOne] = (vexRT[Ch3] - vexRT[Ch1]);
			motor[WheelLeftOne] = (vexRT[Ch3] + vexRT[Ch1]);
			motor[WheelRightTwo] = (vexRT[Ch3] - vexRT[Ch1]);
			motor[WheelLeftTwo] = (vexRT[Ch3] + vexRT[Ch1]);


			if (abs(motor[WheelRightOne]) < 15 || abs(motor[WheelLeftOne]) < 15 ||
				abs(motor[WheelRightTwo]) < 15 || abs(motor[WheelLeftTwo]) < 15) {
				MoveHelper(0);
			}


			if (vexRT[Btn8U] == 1) {
				if (vexRT[Btn5D] == 1) {
					// For Hang
					long startTime = nPgmTime;
					while(abs(nPgmTime - startTime) < 2000) {
						MoveHelper(MaxPower);
						if (vexRT[Btn8L] == 1)
						{
							break;
						}
					}
					MoveHelper(0);
				}
				//}
			}
		}
	}
}

// task MoveForwardForHang()
// {
// 	MoveHelper(128);
// 	// wait1Msec(2000);
// 	// MoveHelper(0);
// }



task Hang()
{
	while (true)
	{
		wait1Msec(50);

		if (vexRT[Btn8U] == 0) {

			if (vexRT[Btn5U] == 1) {
				LiftUp(30);
				wait1Msec(200);
				LiftUp(0);
			}
			else if (vexRT[Btn5D] == 1) {
				LiftDown(20);
				wait1Msec(50);
				LiftDown(0);

			}
			} else if (vexRT[Btn8U] == 1) {

			if (vexRT[Btn5U] == 1) {
				LiftUpAndStop(2500, MaxPower);
			}
			else if (vexRT[Btn5D] == 1) {

				ClawHelper(MaxPower);

				int pValue = 2800;
				waitUntil(abs(SensorValue[LeftClawPosition]) > pValue || abs(SensorValue[RightClawPosition]) > pValue);
				StopClaw();


				writeDebugStreamLine("Hang) StopClaw");



				LiftDownAndStop_Touch(MaxPower, 10000);

				writeDebugStreamLine("Hang) LiftDownAndStop_Touch");


				ClawLeftWorking = ClawRightWorking = true;
				ClawHelper(MaxPower);


				writeDebugStreamLine("Hang) ClawHelper");

				int liftPower = AdjustPowerUsingExternalBatteryLevel(70);
				LiftDown(liftPower);

				writeDebugStreamLine("Hang) LiftDown");


				pValue = 3350;
				waitUntil((abs(SensorValue[LeftClawPosition]) > pValue || abs(SensorValue[RightClawPosition]) > pValue)
				|| (ClawLeftWorking == false || (ClawRightWorking == false)));

				ClawHelper(5);
				wait1Msec(500);
				LiftStop();
				writeDebugStreamLine("Hang) LiftStop");

				StopClaw();
				writeDebugStreamLine("Hang) StopClaw");


			}
		}
	}
}

task ClawLeftControl()
{
	long sameTime;
	int oldPos;
	int curPos = abs(SensorValue[LeftClawPosition]);

	while (true) {
		wait1Msec(50);

		while (ClawLeftWorking == true) {
			oldPos = curPos;
			curPos = abs(SensorValue[LeftClawPosition]);
			sameTime = nPgmTime;
			// writeDebugStreamLine("ClawLeftControl) #1 sameTime updated, oldPos:%d, curPos:%d", oldPos, curPos);

			while (abs(oldPos - curPos) <= 3 ) {
				// writeDebugStreamLine("ClawLeftControl) #2 nPgmTime:%d, sameTime:%d, abs(nPgmTime - sameTime): %d, oldPos:%d, curPos:%d", nPgmTime, sameTime, abs(nPgmTime - sameTime), oldPos, curPos);

				if (abs(nPgmTime - sameTime) > 1000) {
					writeDebugStreamLine("ClawLeftControl) Claw Timeout");

					ClawLeftWorking = false;
					break;
				}

				if (ClawLeftWorking == false)
				{
					// writeDebugStreamLine("ClawLeftControl) Claw reach to target");
					break;
				}

				oldPos = curPos;
				curPos = abs(SensorValue[LeftClawPosition]);
				// writeDebugStreamLine("ClawLeftControl) #3 oldPos:%d, curPos:%d", oldPos, curPos);

			}
		}
	}
}


task ClawRightControl()
{
	long sameTime;
	int oldPos;
	int curPos = abs(SensorValue[RightClawPosition]);

	while (true) {
		wait1Msec(50);

		while (ClawRightWorking == true) {
			oldPos = curPos;
			curPos = abs(SensorValue[RightClawPosition]);
			sameTime = nPgmTime;
			// writeDebugStreamLine("ClawRightControl) #1 sameTime updated, oldPos:%d, curPos:%d", oldPos, curPos);

			while (abs(oldPos - curPos) <= 3 ) {
				// writeDebugStreamLine("ClawRightControl) #2 nPgmTime:%d, sameTime:%d, abs(nPgmTime - sameTime): %d, oldPos:%d, curPos:%d", nPgmTime, sameTime, abs(nPgmTime - sameTime), oldPos, curPos);

				if (abs(nPgmTime - sameTime) > 1000) {
					writeDebugStreamLine("ClawRightControl) Claw Timeout");

					ClawRightWorking = false;
					break;
				}

				if (ClawRightWorking == false)
				{
					// writeDebugStreamLine("ClawRightControl) Claw reach to target");
					break;
				}

				oldPos = curPos;
				curPos = abs(SensorValue[RightClawPosition]);
				// writeDebugStreamLine("ClawRightControl) #3 oldPos:%d, curPos:%d", oldPos, curPos);

			}
		}
	}
}



task ClawLeftTask()
{
	while (true)
	{
		wait1Msec(50);

		if (vexRT[Btn8L] == 1)
		{
			ClawHelperLeft(0);
		}

		if (vexRT[Btn8U] == 0)
		{

			int positionOpen = 1400;

			if (abs(SensorValue[LeftClawPosition]) > 1300) {
				positionOpen = 2100;
			}
			// else if (abs(SensorValue[LeftClawPosition]) > 2400) {
			// 	positionOpen = 3000;
			// }

			if (vexRT[Btn6D] == 1)
			{
				if ((SensorValue[LiftPosition]) < 1500)
				{
					// LiftDown(20);
				}


				ClawLeftWorking = true;
				// open
				while (abs(SensorValue[LeftClawPosition])<abs(positionOpen)){

					if (vexRT[Btn8L] == 1 || ClawLeftWorking == false) {
						// writeDebugStreamLine("ClawLeftTask) Open: Claw Timeout");

						break;
					}

					ClawHelperLeft(MaxPower);
				}

				// writeDebugStreamLine("ClawLeftTask) break");

				ClawLeftWorking = false;

				ClawHelperLeft(0);
				// if (vexRT[Btn8L] == 1)
				// {
				// 	break;
				// }


				//MoveHanging(power);
				//MoveClaw(power);
			}
			else if (vexRT[Btn6U] == 1)
			{
				// close
				if ((SensorValue[LiftPosition]) < 1500)
				{
					// LiftDown(20);
				}

				int powerLocal = -MaxPower;

				if (SensorValue[LeftClawPosition] < 340) {
					powerLocal = -20;
				}

				ClawHelperLeft(powerLocal);
				wait1Msec(120);
				ClawHelperLeft(-20);
			}
			else if (vexRT[Btn6U] == 5)
			{
				ClawLeftWorking = true;
				// close
				while (abs(SensorValue[LeftClawPosition])>abs(700)){


					if (vexRT[Btn8L] == 1 || ClawLeftWorking == false) {
						// writeDebugStreamLine("ClawLeftTask) Close: Claw Timeout");

						break;

					}

					ClawHelperLeft(-MaxPower);
				}

				// writeDebugStreamLine("ClawLeftTask) break");

				ClawLeftWorking = false;

				ClawHelperLeft(-30);
				//MoveHanging(power);
				//MoveClaw(power);
			}
			} else if (vexRT[Btn8U] == 1) {

			int positionOpen = 0;
			int holdPower = 0;

			if (vexRT[Btn6D] == 1) {
				positionOpen = 3500;
				holdPower = 5;
			}
			else if (vexRT[Btn5U] == 1) {
				positionOpen = 2400;
				holdPower = 0;
			}

			ClawLeftWorking = true;
			// open
			while (abs(SensorValue[LeftClawPosition])<abs(positionOpen)){

				if (vexRT[Btn8L] == 1 || ClawLeftWorking == false) {
					// writeDebugStreamLine("ClawLeftTask) Open: Claw Timeout");

					break;
				}
				int power = AdjustPowerUsingBatteryLevel(MaxPower);
				ClawHelperLeft(power);
			}

			// writeDebugStreamLine("ClawLeftTask) break");

			ClawLeftWorking = false;

			ClawHelperLeft(holdPower);

		}
	}
}



task ClawRightTask()
{
	while (true)
	{
		wait1Msec(50);

		if (vexRT[Btn8L] == 1)
		{
			ClawHelperRight(0);
		}

		if (vexRT[Btn8U] == 0)
		{

			int positionOpen = 1500;

			if (abs(SensorValue[RightClawPosition]) > 1400) {
				positionOpen = 2200;
			}
			// else if (abs(SensorValue[RightClawPosition]) > 2400) {
			// 	positionOpen = 3000;
			// }

			if (vexRT[Btn6D] == 1)
			{

				if ((SensorValue[LiftPosition]) < 1500)
				{
					// LiftDown(20);
				}

				ClawRightWorking = true;
				// open
				while (abs(SensorValue[RightClawPosition])<abs(positionOpen)){

					if (vexRT[Btn8L] == 1 || ClawRightWorking == false) {
						// writeDebugStreamLine("ClawRightTask) Open: Claw Timeout");

						break;
					}

					ClawHelperRight(MaxPower);
				}

				// writeDebugStreamLine("ClawRightTask) break");

				ClawRightWorking = false;

				ClawHelperRight(0);
				// if (vexRT[Btn8L] == 1)
				// {
				// 	break;
				// }


				//MoveHanging(power);
				//MoveClaw(power);
			}
			else if (vexRT[Btn6U] == 1)
			{
				// close

				if ((SensorValue[LiftPosition]) < 1500)
				{
					// LiftDown(20);
				}

				int powerLocal = -MaxPower;

				if (SensorValue[RightClawPosition] < 300) {
					powerLocal = -20;
				}

				ClawHelperRight(powerLocal);
				wait1Msec(120);
				ClawHelperRight(-20);
			}
			else if (vexRT[Btn6U] == 5)
			{
				ClawRightWorking = true;
				// close
				while (abs(SensorValue[RightClawPosition])>abs(700)){


					if (vexRT[Btn8L] == 1 || ClawRightWorking == false) {
						// writeDebugStreamLine("ClawRightTask) Close: Claw Timeout");

						break;

					}

					ClawHelperRight(-MaxPower);
				}

				// writeDebugStreamLine("ClawRightTask) break");

				ClawRightWorking = false;

				ClawHelperRight(-30);
				//MoveHanging(power);
				//MoveClaw(power);
			}
		}
		else if (vexRT[Btn8U] == 1) {

			int positionOpen = 0;
			int holdPower = 0;

			if (vexRT[Btn6D] == 1) {
				positionOpen = 3500;
				holdPower = 5;
			}
			else if (vexRT[Btn5U] == 1) {
				positionOpen = 2800;
				holdPower = 0;
			}

			ClawRightWorking = true;
			// open
			while (abs(SensorValue[RightClawPosition])<abs(positionOpen)){

				if (vexRT[Btn8L] == 1 || ClawRightWorking == false) {
					// writeDebugStreamLine("ClawRightTask) Open: Claw Timeout");

					break;
				}

				int power = AdjustPowerUsingBatteryLevel(MaxPower);
				ClawHelperRight(power);
			}

			// writeDebugStreamLine("ClawRightTask) break");

			ClawRightWorking = false;

			ClawHelperRight(holdPower);
		}
	}
}


void OpenClaw(int power)
{
	ClawHelper(power);
}

void CloseClaw(int power)
{
	ClawHelper(-power);
}

void StopClaw()
{
	ClawHelper(0);
}

void ClawHelperLeft(int power)
{
	// motor[ClawRight] = power;
	motor[ClawLeft] = power;
}

void ClawHelperRight(int power)
{
	// motor[ClawRight] = power;
	motor[ClawRight] = power;
}


void ClawHelper(int power)
{
	motor[ClawRight] = power;
	motor[ClawLeft] = power;
}

void DeployClaw()
{
	ClawHelper(60);
	wait1Msec(500);
	ClawHelper(0);
}

// void SetKnockDown()

void SetKnockDown()
{
	int targetLift = 1900;
	int targetLeftClaw = 1300;
	int targetRightClaw = 1400;
	SetPositionHelper(true, targetLift, targetLeftClaw, targetRightClaw);
}


void SetPositionClawOnlyHelper(bool increase, int targetLeftClaw, int targetRightClaw)
{
	// Up slowly lift
	// int powerLift = 70;

	int power = (increase)? MaxPower : -MaxPower;

	while(true)
	{
		ClawHelper(power);

		if (increase) {
			if (SensorValue[LeftClawPosition] > targetLeftClaw) {
				ClawHelperLeft(0);
			}

			if (SensorValue[RightClawPosition] > targetRightClaw) {
				ClawHelperRight(0);
			}
		}
		else
		{
			if (SensorValue[LeftClawPosition] < targetLeftClaw) {
				ClawHelperLeft(0);
			}

			if (SensorValue[RightClawPosition] < targetRightClaw) {
				ClawHelperRight(0);
			}
		}

		if ((motor[ClawLeft] == 0 && motor[ClawRight] == 0 ) || vexRT[Btn8L] == 1) {
			break;
		}

	}


}

void SetPositionHelper(bool increase, int targetLift, int targetLeftClaw, int targetRightClaw)
{
	// Up slowly lift
	// int powerLift = 70;

	int power = (increase)? MaxPower : -MaxPower;

	while(true)
	{
		ClawHelper(power);
		LiftUp(MaxPower);


		if (increase) {
			if (SensorValue[LeftClawPosition] > targetLeftClaw) {
				ClawHelperLeft(0);
			}

			if (SensorValue[RightClawPosition] > targetRightClaw) {
				ClawHelperRight(0);
			}
		}
		else
		{
			if (SensorValue[LeftClawPosition] < targetLeftClaw) {
				ClawHelperLeft(0);
			}

			if (SensorValue[RightClawPosition] < targetRightClaw) {
				ClawHelperRight(0);
			}
		}

		if (SensorValue(LiftPosition) > targetLift) {
			LiftUp(0);
		}

		if ((motor[ClawLeft] == 0 && motor[ClawRight] == 0 && motor[Lift_L1] == 0) || vexRT[Btn8L] == 1) {
			break;
		}

	}


}

task Lift()
{
	while (true)
	{
		wait1Msec(50);



		if (vexRT[Ch3] > 10) {
			if ((SensorValue[LiftPosition]) < 1500)
			{
				LiftDown(20);
			}
		}

		if (vexRT[Btn7R] == 1)
		{
			// testMode = true;
			// ProgrammingSkill();
			// testMode = false;

		}
		else if (vexRT[Btn7L] == 1)
		{
			SetKnockDown();
		}
		else if (vexRT[Btn8R] == 1)
		{
			// Up slowly lift
			// int powerLift = 75;
			// int targetPosition = 1300;

			int powerLift = MaxPower;
			int targetPosition = 1000;

			if (SensorValue(LiftPosition) > 1000) {
				targetPosition = 1600;
			}

			// CloseClaw(20);

			while (SensorValue(LiftPosition) < targetPosition/*&&(vexRT[Btn7U]==0)*/){
				//if (vexRT[Btn7U]==1){
				//	MoveLift(100);
				//}
				LiftUp(powerLift);

				if (vexRT[Btn8L] == 1)
				{
					break;
				}
			}

			LiftUp(20);
		}
		else if (vexRT[Btn8U] == 0)
		{
			if (vexRT[Btn7U] == 1)
			{
				Throw(3000 + 400, 2000 + 500, MaxPower);
				LiftDownAndStop_Touch_DefaultTimeout(40);
				// LiftUpAndStop(2600, 120);
			}
			else if (vexRT[Btn7D] == 1)
			{
				// Down lift
				// LiftDownAndStop(900,  40);
				LiftDownAndStop_Touch_DefaultTimeout(60);
				LiftDown(10);
			}
		}
		else if (vexRT[Btn8U] == 1){
			if (vexRT[Btn7U] == 1)
			{
				LiftUp(MaxPower);
			}
			else if (vexRT[Btn7D] == 1)
			{
				LiftDown(MaxPower);
				wait1Msec(300);
				LiftDown(70);
			}
		}
	}
}

void Throw(int distanceLift, int distanceToThrow, int power){

	// CloseClaw(10);

	while (abs(SensorValue[LiftPosition])<abs(distanceLift)){
		LiftUp(power);
		if (vexRT[Btn8L] == 1)
		{
			break;
		}

		if (abs(SensorValue[LiftPosition]) > distanceToThrow ){
			OpenClaw(100);
			// power = 0;
		}
	}

	LiftStop();
	StopClaw();
	LiftDownAndStop_Touch_DefaultTimeout(60);
	LiftDown(10);
}

void LiftUpNoStop(int distance, int power) {

	while (abs(SensorValue[LiftPosition])<abs(distance)){
		LiftUp(power);
		if (vexRT[Btn8L] == 1)
		{
			break;
		}
	}
	// MoveLift(0);
}

void LiftStop()
{
	LiftHelper(0);
}

void LiftUpAndStop(int distance, int power)
{
	while (abs(SensorValue[LiftPosition])<abs(distance)){
		LiftUp(power);
		if (vexRT[Btn8L] == 1)
		{
			break;
		}
	}
	LiftStop();
}

void LiftUp(int power)
{
	LiftHelper(power);
}

void LiftDownAndStop_Touch_DefaultTimeout(int power) {
	LiftDownAndStop_Touch(power, 3000);
}

void LiftDownAndStop_Touch(int power, int timemout) {

	long startTime = nPgmTime;

	while (SensorValue[LiftTouch] == 0){

		// writeDebugStreamLine("LiftDownAndStop_Touch) LiftPosition: %d Touch: %d", abs(SensorValue[LiftPosition]), SensorValue[LiftTouch]);

		LiftDown(power);
		if (vexRT[Btn8L] == 1 || (nPgmTime - startTime) > timemout)
		{
			break;
		}
	}

	if (SensorValue[LiftTouch] == 1){
		// writeDebugStreamLine("LiftDownAndStop_Touch) Touched");
		writeDebugStreamLine("LiftDownAndStop_Touch) LiftPosition: %d Touch: %d", abs(SensorValue[LiftPosition]), SensorValue[LiftTouch]);
	}

	LiftStop();
}

void LiftDownAndStop(int distance, int power) {

	while (abs(SensorValue[LiftPosition])>abs(distance)){

		// writeDebugStreamLine("LiftDownAndStop) LiftPosition: %d", SensorValue[LiftPosition]);

		LiftDown(power);
		if (vexRT[Btn8L] == 1)
		{
			break;
		}
	}
	LiftStop();
}

void StartClaw(){

}

void LiftDown(int power)
{
	LiftHelper(-power);
}

void LiftHelper(int power)
{
	motor[Lift_L1] = power;
	motor[Lift_L2] = power;
	motor[Lift_R1] = power;
	motor[Lift_R2] = power;
}

int AdjustPowerUsingBatteryLevel(int originalPower)
{
	float batteryLevel = nImmediateBatteryLevel;
	float batteryOffset =	7000 / batteryLevel;
	int adjustedPower = originalPower * batteryOffset;
	//  writeDebugStreamLine("(AjustBattery) BatterLevel: %d - OriginalPower: %d - WantedPower: %d", AdjustBatteryLevel, OriginalPower, WantedPower);
	return adjustedPower;
}

int AdjustPowerUsingExternalBatteryLevel(int originalPower)
{
	float batteryLevel = SensorValue[ExternalBatteryValue] * 3.57;

	float batteryOffset =	7000 / batteryLevel;
	int adjustedPower = originalPower * batteryOffset;
	//  writeDebugStreamLine("(AjustBattery) BatterLevel: %d - OriginalPower: %d - WantedPower: %d", AdjustBatteryLevel, OriginalPower, WantedPower);
	return adjustedPower;
}


task usercontrol()
{
	// User control code here, inside the loop

	startTask(StopAll);
	startTask(ClawLeftControl);
	startTask(ClawRightControl);
	startTask(ClawLeftTask);
	startTask(ClawRightTask);
	startTask(Lift);
	startTask(Move);
	startTask(Hang);
	while (true)
	{
		// This is the main execution loop for the user control program.
		// Each time through the loop your program should update motor + servo
		// values based on feedback from the joysticks.

		// ........................................................................
		// Insert user code here. This is where you use the joystick values to
		// update your motors, etc.
		// ........................................................................


	}
}
