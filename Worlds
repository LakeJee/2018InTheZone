#pragma config(Sensor, in1,    Arm,            sensorPotentiometer)
#pragma config(Sensor, dgtl12, Launcher,       sensorTouch)
#pragma config(Motor,  port1,           Claw,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           LiftFour,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LiftFive,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LauncherThree, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LeftWheels,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           RightWheels,   tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           LiftOne,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           LiftTwo,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LiftThree,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          LiftSix,       tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!


void MoveClaw (int ClawPower);
void StopAll();
task StopLift();
void LiftUp();

task Move();
task Lift();
task HoldPower();
//gloabal variable
bool actionUp = false;
bool isUp = false;
bool isOpen = true;
bool readSensor = true;

int basePower = 30;
int offset = 0;


/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	startTask (Move);
	//startTask (HoldPower);

	while (true)
	{
		wait1Msec(10);

		if (vexRT[Btn7R] == 1)
		{
			offset = offset + 5;
		}
		if (vexRT[Btn7L]==1)
		{
			LiftUp();
		}
		//else if (vexRT[Btn7L] == 0)
		//{
		//			startTask(StopLift);
		//}
		//if (vexRT[Btn7L] == 1)
		//{
		//	offset = offset - 5;
		//}

		/*if (vexRT[Btn8U] == 1)
		{
		LauncherDown(127);
		wait1Msec(0);
		waitUntil(SensorValue[Launcher]==1);
		{
		wait1Msec(80);
		LauncherDown(20);
		if (vexRT[Btn8D] ==1)
		{
		LauncherDown(100);
		wait1Msec(500);
		LauncherDown(0);
		}
		}

		// LauncherDown(40);
		}
		if (vexRT[Btn8D] == 1)
		{
		LauncherDown(0);
		wait1Msec(10);
		}*/
		if (vexRT[Btn6U] == 1)
		{
			isOpen = false;
			// Closing
			MoveClaw(-120);

			/*if (vexRT[Btn6U] == 0)
			{
			MoveClaw(-60);
			}*/
		}
		else if (vexRT[Btn6U] == 0)
		{
			if (isOpen == false)
			{
				MoveClaw(-15);
			}
		}

		if (vexRT[Btn6D] == 1)
		{ // Opeining
			isOpen = true;
			MoveClaw(120);
		}
		else if (vexRT[Btn6D] == 0)
		{
			if (isOpen == true)
			{
				MoveClaw(15);
			}
		}


		if (vexRT[Btn8L] == 1)
		{
			StopAll();
		}
		if (vexRT[Btn7U] == 1)
		{
			actionUp = true;
			isUp = true;
			startTask (Lift);
		}
		else if (vexRT[Btn7U] == 0)
		{
			if (isUp == true)
			{
				startTask (HoldPower);
			}
			//if (isUp != false)
			//{
			//		isUp = true;
			//stopTask (Lift);
			//startTask (StopLift);
		}
		if (vexRT[Btn7D] == 1)
		{
			isUp = false;
			actionUp = true;

			stopTask(HoldPower);
			startTask (Lift);
		}
		else if (vexRT[Btn7D] == 0)
		{
			//stopTask(HoldPower);

			if (isUp != true)
			{
				//		isUp = true;
				stopTask (Lift);
				startTask (StopLift);
			}
		}
		/*if (vexRT[Btn5U] == 1)
		{
		MoveSpool(-80);
		wait1Msec(10);
		if (vexRT[Btn5U] == 0)
		{
		MoveSpool(0);
		wait1Msec(10);
		}
		}
		if (vexRT[Btn5D] == 1)
		{
		MoveSpool(80);
		wait1Msec(10);
		if (vexRT[Btn5D] == 0)
		{
		MoveSpool(0);
		wait1Msec(10);
		}
		}*/
		/*
		if (SensorValue[Arm] > 2500){
		startTask (HoldPower);
		readSensor = true;

		if (vexRT[Btn7D] == 1)
		{
		readSensor = false;
		}
		}
		if (SensorValue[Arm] < 1100){
		wait1Msec(50);
		motor[LiftOne]= 20;
		motor[LiftTwo]= 20;
		motor[LiftThree]= 20;
		motor[LiftFour]= 20;
		motor[LiftFive]= 20;

		*/
	}

}
void LiftUp ()
{
	int power = -80;
	motor[LiftOne] =	power;
	motor[LiftTwo] = power;
	motor[LiftThree] = power;
	motor[LiftFour] = power;
	motor[LiftFive] = power;
	motor[LiftSix] = power;
}
void MoveClaw (int ClawPower)
{
	motor[Claw] = ClawPower;
}

void StopAll()
{
	motor[Claw] = 0;

	int power = 0;
	motor[LiftOne] =	power;
	motor[LiftTwo] = power;
	motor[LiftThree] = power;
	motor[LiftFour] = power;
	motor[LiftFive] = power;
	motor[LiftSix] = power;

}
task StopLift()
{
	int power = 0;
	motor[LiftOne] =	power;
	motor[LiftTwo] = power;
	motor[LiftThree] = power;
	motor[LiftFour] = power;
	motor[LiftFive] = power;
	motor[LiftSix] = power;
}
task Lift()
{
	int power = 120;
	if (isUp == true)
	{
		power = -100;
	}
	motor[LiftOne] =	power;
	motor[LiftTwo] = power;
	motor[LiftThree] = power;
	motor[LiftFour] = power;
	motor[LiftFive] = power;
	motor[LiftSix] = power;
}

task Move ()
{
	while (true)
	{
		motor[LeftWheels] = vexRT[Ch3] + vexRT[Ch1];
		motor[RightWheels] = vexRT[Ch3] - vexRT[Ch1];

		EndTimeSlice();
	}
}

task HoldPower()
{

	//int power = 30;

	//while (true)
	//{

	int power = (basePower + offset) * -1;

	//if (readSensor == true)
	//{
	//	power = -30;
	//	if (vexRT[Btn7R] = 1){
	//		power = power + 5;
	//	}
	//}
	//if (isUp == false)
	//{
	//	power = power * -1;
	//}

	//power = 0;

	motor[LiftOne] = power;
	motor[LiftTwo] = power;
	motor[LiftThree] = power;
	motor[LiftFour] = power;
	motor[LiftFive] = power;
	motor[LiftSix] = power;

	//}


	//}
}
