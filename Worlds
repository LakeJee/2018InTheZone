#pragma config(Sensor, in1,    LiftPosition,   sensorPotentiometer)
#pragma config(Sensor, in2,    LeftClawPosition, sensorPotentiometer)
#pragma config(Sensor, in3,    RightClawPosition, sensorPotentiometer)
#pragma config(Sensor, in4,    ExternalBatteryValue, sensorAnalog)
#pragma config(Sensor, in5,    Accel_y,        sensorAccelerometer)
#pragma config(Sensor, in6,    GyroPosition,   sensorGyro)
#pragma config(Sensor, dgtl2,  LiftTouch,      sensorTouch)
#pragma config(Motor,  port1,           ClawLeft,      tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           WheelLeftOne,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           WheelLeftTwo,  tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           Lift_R1,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           Lift_R2,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           Lift_L1,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           Lift_L2,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           WheelRightOne, tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           WheelRightTwo, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          ClawRight,     tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"




task StopAll();
task Move();
task ClawLeftControl();
task ClawRightControl();
task ClawLeftTask();
task ClawRightTask();
task Lift();
task Hang();


// Autonomous
void ProgrammingSkill();
void ProgrammingSkill_1();
void ProgrammingSkill_2();

void MoveHelper(int power);
void MoveValue(int distance, int power);
void MoveValue_Accel(int distance, int power);
void MoveForward(int distance, int power);
void MoveBackward(int distance, int power);

// User Controls
int AdjustPowerUsingBatteryLevel(int originalPower);
int AdjustPowerUsingExternalBatteryLevel(int originalPower);

void LiftHelper(int power);

void Turn(int power);
void TurnRight(int distance, int power);
void TurnLeft(int distance, int power);
void TurnValueGyro(int distance, int power);

void ClawHelper(int power);
void ClawHelperLeft(int power);
void ClawHelperRight(int power);

void Throw(int distanceLift, int distanceToThrow, int power);
void LiftDownAndStop(int distance, int power);
void LiftDownAndStop_Touch_DefaultTimeout(int power);
void LiftDownAndStop_Touch(int power, int timemout);

void LiftDown(int power);
void LiftUp(int power);
void LiftUpAndStop(int distance, int power);
void LiftUpNoStop(int distance, int power);
void LiftStop();

void OpenClaw(int power);
void CloseClaw(int power);
void StopClaw();

void SetKnockDown();
void SetPositionHelper(bool increase, int targetLift, int targetLeftClaw, int targetRightClaw);
void SetPositionClawOnlyHelper(bool increase, int targetLeftClaw, int targetRightClaw);

const int MaxPower = 127;
bool ClawLeftWorking = false;
bool ClawRightWorking = false;

int autonomousMode = 1;
int globalWaiter = 200;
bool testMode = false;

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	bStopTasksBetweenModes = true;

	SensorValue[GyroPosition] = sensorNone;
	SensorValue[Accel_y] = sensorNone;
	wait1Msec(1000);

	SensorValue[GyroPosition] = sensorGyro;
	SensorType[Accel_y] = sensorAccelerometer;

	// SensorScale[GyroPosition] = 260;
	// SensorScale[GyroPosition] = 100;
	//Adjust SensorFullCount to set the "rollover" point. 3600 sets the rollover point to +/-3600
	SensorFullCount[GyroPosition] = 3600;

	SensorValue[GyroPosition] = 0;
	SensorValue[Accel_y] = 0;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	long startTime = nPgmTime;

	SensorValue[GyroPosition] = 0;

	// LockWheel(); // LockWheel should be in the pre_auto

	autonomousMode = 5;

	if (autonomousMode == 1)
	{
		// Autonomous_Accel();
	}
	else if (autonomousMode == 2)
	{
		// Autonomous_IEM();
	}
	else if (autonomousMode == 3)
	{
		// Autonomous_2SL();
	}
	else if (autonomousMode == 4)
	{
		// Autonomous_2SR();
	}
	else if (autonomousMode == 5)
	{
		// ProgrammingSkill_Extended();
		ProgrammingSkill();
	}
	else if (autonomousMode == 6)
	{
		// Inspection();
	}
	else
	{
		// Autonomous_Accel();
	}

	writeDebugStreamLine("autonomous) Time: %d", nPgmTime - startTime);
}


void ProgrammingSkill(){


	long startTime = nPgmTime;


	SetKnockDown();

	wait1Msec(globalWaiter);

	MoveForward(1900, 100); //move forward to the wall

	wait1Msec(globalWaiter * 3);

	MoveBackward(200, 70); //move backward to the wall

	wait1Msec(globalWaiter * 3);

	TurnLeft(1500, 60); //90 degrees is around 440
	// wait1Msec(globalWaiter * 3);

	LiftDownAndStop_Touch_DefaultTimeout(40);
	LiftDown(10);

	MoveForward(250, 70); //move forward to the wall to pick up


	writeDebugStreamLine("autonomous) KnockDown: %d", nPgmTime - startTime);

	ProgrammingSkill_1();

	wait1Msec(globalWaiter * 3);

	ProgrammingSkill_2();

	writeDebugStreamLine("autonomous) Done: %d", nPgmTime - startTime);



}

void ProgrammingSkill_2(){
	int pValue = 0;
	int goBack = 0;

	// LiftUp(30);
	// 			wait1Msec(0);

	// CloseClaw(MaxPower);
	// wait1Msec(200);

	// LiftUp(0);
	// CloseClaw(0);

	SetPositionHelper(false, 800, 400, 400);

	wait1Msec(globalWaiter);

	TurnRight(530, 60); //90 degrees is around 440

	writeDebugStreamLine("ProgrammingSkill) TurnRight");


	{	// Move Back
		goBack = 10;
		MoveBackward(goBack, 50); //move back from the wall

		writeDebugStreamLine("ProgrammingSkill) MoveBackward");
	}


	LiftDownAndStop_Touch_DefaultTimeout(40);
	LiftDown(20);
	writeDebugStreamLine("ProgrammingSkill) LiftDown");


	wait1Msec(globalWaiter);

	MoveHelper(70);
	wait1Msec(400);
	MoveHelper(0);


	SetPositionClawOnlyHelper(true, 900, 1000);

	// { // Open Claw
	// 	OpenClaw(MaxPower);
	//  	pValue = 700;
	// 	waitUntil(SensorValue[LeftClawPosition] > pValue || SensorValue[RightClawPosition] > pValue);
	// 	StopClaw();

	// 	writeDebugStreamLine("ProgrammingSkill) OpenClaw");

	// }

	wait1Msec(globalWaiter  * 2);



	{	// Move Forward
		goBack = 500;
		MoveForward(goBack, 70); //move back from the wall

		writeDebugStreamLine("ProgrammingSkill) MoveForward");
	}



	{ // Close Claw
		ClawLeftWorking = ClawRightWorking = true;
		CloseClaw(MaxPower);

		pValue = 800;
		waitUntil((SensorValue[LeftClawPosition] < pValue || SensorValue[RightClawPosition] < pValue)
		|| (ClawLeftWorking == false || (ClawRightWorking == false)));
	}

	wait1Msec(globalWaiter);

	CloseClaw(5);

	TurnLeft(200, 60); //90 degrees is around 440

	wait1Msec(globalWaiter);

	{
		// Raise and Hold
		LiftUpAndStop(2000, 85);
		LiftUp(20);
	}

	TurnLeft(330, 60); //90 degrees is around 440

	wait1Msec(globalWaiter * 3);



	MoveHelper(-40);
	wait1Msec(500);
	MoveHelper(0);

	
	Throw(3000 + 400, 2000 + 500, MaxPower); // throw three stars #1

	// MoveHelper(-20);
	wait1Msec(globalWaiter);


	{ // Open Claw
		OpenClaw(MaxPower);
		pValue = 1600;
		waitUntil(SensorValue[LeftClawPosition] > pValue || SensorValue[RightClawPosition] > pValue);
		StopClaw();
	}

	wait1Msec(globalWaiter);

	MoveHelper(30);
	wait1Msec(globalWaiter);


	{ // Close Claw
		ClawLeftWorking = ClawRightWorking = true;
		CloseClaw(MaxPower);

		pValue = 800;
		waitUntil((SensorValue[LeftClawPosition] < pValue || SensorValue[RightClawPosition] < pValue)
		|| (ClawLeftWorking == false || (ClawRightWorking == false)));
	}

	wait1Msec(globalWaiter);

	CloseClaw(5);

	{
		// Raise and Hold
		LiftUpAndStop(2000, 85);
		LiftUp(20);
	}


	MoveHelper(-40);
	wait1Msec(globalWaiter * 3);
	MoveHelper(0);
	
	Throw(3000 + 400, 2000 + 500, MaxPower); // throw cube #1

	// MoveHelper(-20);
	wait1Msec(globalWaiter);


	{ // Open Claw
		OpenClaw(MaxPower);
		pValue = 1600;
		waitUntil(SensorValue[LeftClawPosition] > pValue || SensorValue[RightClawPosition] > pValue);
		StopClaw();
	}

	wait1Msec(globalWaiter);

	{	// Move Forward
		goBack = 320;
		MoveForward(goBack, 100); //move forward to wall to pick up
	}

	wait1Msec(globalWaiter);


	{ // Close Claw
		ClawLeftWorking = ClawRightWorking = true;
		CloseClaw(MaxPower);

		pValue = 800;
		waitUntil((SensorValue[LeftClawPosition] < pValue || SensorValue[RightClawPosition] < pValue)
		|| (ClawLeftWorking == false || (ClawRightWorking == false)));
	}

	wait1Msec(globalWaiter * 2);


	CloseClaw(5);

	{	// Move Back
		goBack = 50;
		MoveBackward(goBack, 100); //move back from the wall
	}

	{
		// Raise and Hold
		LiftUpAndStop(2000, 85);
		LiftUp(20);
	}

	{	// Move Back
		MoveBackward(400, 100); //move back to fence to throw
	}


	MoveHelper(-40);
	wait1Msec(globalWaiter);
	MoveHelper(0);
	
	Throw(3000 + 400, 2000 + 500, MaxPower); // throw three stars #2

	// MoveHelper(-20);
	wait1Msec(globalWaiter);


}

void ProgrammingSkill_1(){


	long startTime = nPgmTime;

	int goBack = 0;
	int pValue = 0;

	// { // Open Claw
	// 	OpenClaw(MaxPower);
	//  	pValue = 1800;
	// 	waitUntil(SensorValue[LeftClawPosition] > pValue || SensorValue[RightClawPosition] > pValue);
	// 	StopClaw();
	// }

	// // Lower Lift
	// LiftDownAndStop_Touch_DefaultTimeout(40);
	// LiftDown(10);

	for (int i = 0; i < 3; i++) {

		wait1Msec(1000);

		{ // Close Claw
			ClawLeftWorking = ClawRightWorking = true;
			CloseClaw(MaxPower);

			pValue = 800;
			waitUntil((SensorValue[LeftClawPosition] < pValue || SensorValue[RightClawPosition] < pValue)
			|| (ClawLeftWorking == false || (ClawRightWorking == false)));
		}

		wait1Msec(globalWaiter * 2);

		int powerClaw = 5;

		if (i == 0) {
			powerClaw = 10;
		}

		CloseClaw(powerClaw);

		{	// Move Back
			goBack = 50;
			MoveBackward(goBack, 100); //move back from the wall
		}

		{
			// Raise and Hold
			LiftUpAndStop(2000, 85);
			LiftUp(20);
		}

		{	// Move Back
			goBack = 400;
			if (i == 0) {
				goBack = 1000;
			}

			MoveBackward(goBack, 100); //move back to fence to throw
		}


		MoveHelper(-40);
		wait1Msec(globalWaiter);
		MoveHelper(0);

		// Throw
		Throw(3000 + 400, 2000 + 500, MaxPower);

		// MoveHelper(-10);


		writeDebugStreamLine("autonomous) throw: %d, index: %d", nPgmTime - startTime, i);

		if (i < 2) {
			{ // Open Claw
				OpenClaw(MaxPower);
				pValue = 1600;
				waitUntil(SensorValue[LeftClawPosition] > pValue || SensorValue[RightClawPosition] > pValue);
				StopClaw();
			}


			writeDebugStreamLine("ProgrammingSkill) OpenClaw, index:%d", i);


			// wait1Msec(500);
			// wait1Msec(500);

			{	// Move Back
				goBack = 200;
				MoveForward(goBack, 100); //move forward to wall to pick up
			}


			writeDebugStreamLine("ProgrammingSkill) MoveForward, index:%d", i);
		}
	}
}

void MoveHelper(int power)
{
	motor[WheelRightOne] = power;
	motor[WheelLeftOne] = power;
	motor[WheelRightTwo] = power;
	motor[WheelLeftTwo] = power;
}

void MoveForward(int distance, int power)
{
	MoveValue(distance, power);
}

void MoveBackward(int distance, int power)
{
	MoveValue(distance, -power);
}

void MoveValue(int distance, int power) {
	MoveValue_Accel(distance, power);
	// MoveValue_IEM(distance, power);
}

void MoveValue_Accel(int distance, int power) {
	// ClearEncoder();

	//writeDebugStreamLine("MoveValue_Accel) Started ===");
	//const float offset = 0.8;
	//float distance = distance_or * offset;

	int velocity = 0;
	int position = 0;
	int value = 0;
	clearTimer(T3);
	power = AdjustPowerUsingBatteryLevel(power);
	while (abs(position) < abs(distance)){
		value = SensorValue[Accel_y];
		velocity += value;
		//velocity = (value == 0)? velocity : velocity + value;
		position += velocity;

		// writeDebugStreamLine("MoveValue_Accel) pos: %d, dis: %d ", position, distance);
		if (time1[T3] >= 2000)
		{
			break;
		}
		MoveHelper(power);
		wait1Msec(100);
	}
	MoveHelper(0);
}


void TurnRight(int distance, int power) {
	TurnValueGyro (distance, power);
}

void TurnLeft(int distance, int power) {
	TurnValueGyro (distance, -power);
}

void TurnValueGyro(int distance, int power) {
	// wait1Msec(time);
	SensorValue[GyroPosition] = 0;
	power = AdjustPowerUsingBatteryLevel(power);
	while (abs(SensorValue[GyroPosition])<abs(distance)){
		Turn(power);
	}
	Turn(0);
}

void Turn(int power)
{
	motor[WheelRightOne] = -power;
	motor[WheelLeftOne] = power;
	motor[WheelRightTwo] = -power;
	motor[WheelLeftTwo] = power;
}



/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task StopAll()
{
	while (true)
	{
		wait1Msec(50);

		if (vexRT[Btn8L] == 1)
		{
			// Stops everything
			// int power = 0;
			LiftStop();
			StopClaw();
			//MoveHanging(power);
			//MoveClaw(power);
		}
	}
}


task Move()
{
	while (true)
	{
		wait1Msec(50);

		while(testMode == false) {

			motor[WheelRightOne] = (vexRT[Ch3] - vexRT[Ch1]);
			motor[WheelLeftOne] = (vexRT[Ch3] + vexRT[Ch1]);
			motor[WheelRightTwo] = (vexRT[Ch3] - vexRT[Ch1]);
			motor[WheelLeftTwo] = (vexRT[Ch3] + vexRT[Ch1]);


			if (abs(motor[WheelRightOne]) < 15)
			{
				MoveHelper(0);
			}
		}

		if (vexRT[Btn8U] == 1) {
			if (vexRT[Btn5D] == 1) {
				// For Hang
				long startTime = nPgmTime;
				while(abs(nPgmTime - startTime) < 2000) {
					MoveHelper(128);
					if (vexRT[Btn8L] == 1)
					{
						break;
					}
				}
				MoveHelper(0);
			}
		}
	}
}

// task MoveForwardForHang()
// {
// 	MoveHelper(128);
// 	// wait1Msec(2000);
// 	// MoveHelper(0);
// }



task Hang()
{
	while (true)
	{
		wait1Msec(50);

		if (vexRT[Btn8U] == 0) {

			if (vexRT[Btn5U] == 1) {
				LiftUp(30);
				wait1Msec(200);
				LiftUp(0);
			}
			else if (vexRT[Btn5D] == 1) {
				LiftDown(20);
				wait1Msec(50);
				LiftDown(0);

			}
			} else if (vexRT[Btn8U] == 1) {

			if (vexRT[Btn5U] == 1) {
				LiftUpAndStop(2500, MaxPower);
			}
			else if (vexRT[Btn5D] == 1) {

				ClawHelper(MaxPower);

				int pValue = 2800;
				waitUntil(abs(SensorValue[LeftClawPosition]) > pValue || abs(SensorValue[RightClawPosition]) > pValue);
				StopClaw();


				writeDebugStreamLine("Hang) StopClaw");



				LiftDownAndStop_Touch(MaxPower, 10000);

				writeDebugStreamLine("Hang) LiftDownAndStop_Touch");


				ClawLeftWorking = ClawRightWorking = true;
				ClawHelper(MaxPower);


				writeDebugStreamLine("Hang) ClawHelper");

				int liftPower = AdjustPowerUsingExternalBatteryLevel(70);
				LiftDown(liftPower);

				writeDebugStreamLine("Hang) LiftDown");


				pValue = 3350;
				waitUntil((abs(SensorValue[LeftClawPosition]) > pValue || abs(SensorValue[RightClawPosition]) > pValue)
				|| (ClawLeftWorking == false || (ClawRightWorking == false)));

				ClawHelper(5);
				wait1Msec(500);
				LiftStop();
				writeDebugStreamLine("Hang) LiftStop");

				StopClaw();
				writeDebugStreamLine("Hang) StopClaw");


			}
		}
	}
}

task ClawLeftControl()
{
	long sameTime;
	int oldPos;
	int curPos = abs(SensorValue[LeftClawPosition]);

	while (true) {
		wait1Msec(50);

		while (ClawLeftWorking == true) {
			oldPos = curPos;
			curPos = abs(SensorValue[LeftClawPosition]);
			sameTime = nPgmTime;
			// writeDebugStreamLine("ClawLeftControl) #1 sameTime updated, oldPos:%d, curPos:%d", oldPos, curPos);

			while (abs(oldPos - curPos) <= 3 ) {
				// writeDebugStreamLine("ClawLeftControl) #2 nPgmTime:%d, sameTime:%d, abs(nPgmTime - sameTime): %d, oldPos:%d, curPos:%d", nPgmTime, sameTime, abs(nPgmTime - sameTime), oldPos, curPos);

				if (abs(nPgmTime - sameTime) > 1000) {
					writeDebugStreamLine("ClawLeftControl) Claw Timeout");

					ClawLeftWorking = false;
					break;
				}

				if (ClawLeftWorking == false)
				{
					// writeDebugStreamLine("ClawLeftControl) Claw reach to target");
					break;
				}

				oldPos = curPos;
				curPos = abs(SensorValue[LeftClawPosition]);
				// writeDebugStreamLine("ClawLeftControl) #3 oldPos:%d, curPos:%d", oldPos, curPos);

			}
		}
	}
}


task ClawRightControl()
{
	long sameTime;
	int oldPos;
	int curPos = abs(SensorValue[RightClawPosition]);

	while (true) {
		wait1Msec(50);

		while (ClawRightWorking == true) {
			oldPos = curPos;
			curPos = abs(SensorValue[RightClawPosition]);
			sameTime = nPgmTime;
			// writeDebugStreamLine("ClawRightControl) #1 sameTime updated, oldPos:%d, curPos:%d", oldPos, curPos);

			while (abs(oldPos - curPos) <= 3 ) {
				// writeDebugStreamLine("ClawRightControl) #2 nPgmTime:%d, sameTime:%d, abs(nPgmTime - sameTime): %d, oldPos:%d, curPos:%d", nPgmTime, sameTime, abs(nPgmTime - sameTime), oldPos, curPos);

				if (abs(nPgmTime - sameTime) > 1000) {
					writeDebugStreamLine("ClawRightControl) Claw Timeout");

					ClawRightWorking = false;
					break;
				}

				if (ClawRightWorking == false)
				{
					// writeDebugStreamLine("ClawRightControl) Claw reach to target");
					break;
				}

				oldPos = curPos;
				curPos = abs(SensorValue[RightClawPosition]);
				// writeDebugStreamLine("ClawRightControl) #3 oldPos:%d, curPos:%d", oldPos, curPos);

			}
		}
	}
}



task ClawLeftTask()
{
	while (true)
	{
		wait1Msec(50);

		if (vexRT[Btn8L] == 1)
		{
			ClawHelperLeft(0);
		}

		if (vexRT[Btn8U] == 0)
		{

			int positionOpen = 1200;

			if (abs(SensorValue[LeftClawPosition]) > 1300) {
				positionOpen = 1800;
			}
			// else if (abs(SensorValue[LeftClawPosition]) > 2400) {
			// 	positionOpen = 3000;
			// }

			if (vexRT[Btn6D] == 1)
			{
				ClawLeftWorking = true;
				// open
				while (abs(SensorValue[LeftClawPosition])<abs(positionOpen)){

					if (vexRT[Btn8L] == 1 || ClawLeftWorking == false) {
						// writeDebugStreamLine("ClawLeftTask) Open: Claw Timeout");

						break;
					}

					ClawHelperLeft(MaxPower);
				}

				// writeDebugStreamLine("ClawLeftTask) break");

				ClawLeftWorking = false;

				ClawHelperLeft(0);
				// if (vexRT[Btn8L] == 1)
				// {
				// 	break;
				// }


				//MoveHanging(power);
				//MoveClaw(power);
			}
			else if (vexRT[Btn6U] == 1)
			{
				// close
				if ((SensorValue[LiftPosition]) < 1500)
				{
					LiftDown(10);
				}

				ClawHelperLeft(-MaxPower);
				wait1Msec(120);
				ClawHelperLeft(-20);
			}
			else if (vexRT[Btn6U] == 5)
			{
				ClawLeftWorking = true;
				// close
				while (abs(SensorValue[LeftClawPosition])>abs(700)){


					if (vexRT[Btn8L] == 1 || ClawLeftWorking == false) {
						// writeDebugStreamLine("ClawLeftTask) Close: Claw Timeout");

						break;

					}

					ClawHelperLeft(-MaxPower);
				}

				// writeDebugStreamLine("ClawLeftTask) break");

				ClawLeftWorking = false;

				ClawHelperLeft(-30);
				//MoveHanging(power);
				//MoveClaw(power);
			}
			} else if (vexRT[Btn8U] == 1) {

			int positionOpen = 0;
			int holdPower = 0;

			if (vexRT[Btn6D] == 1) {
				positionOpen = 3500;
				holdPower = 5;
			}
			else if (vexRT[Btn5U] == 1) {
				positionOpen = 2400;
				holdPower = 0;
			}

			ClawLeftWorking = true;
			// open
			while (abs(SensorValue[LeftClawPosition])<abs(positionOpen)){

				if (vexRT[Btn8L] == 1 || ClawLeftWorking == false) {
					// writeDebugStreamLine("ClawLeftTask) Open: Claw Timeout");

					break;
				}
				int power = AdjustPowerUsingBatteryLevel(MaxPower);
				ClawHelperLeft(power);
			}

			// writeDebugStreamLine("ClawLeftTask) break");

			ClawLeftWorking = false;

			ClawHelperLeft(holdPower);

		}
	}
}



task ClawRightTask()
{
	while (true)
	{
		wait1Msec(50);

		if (vexRT[Btn8L] == 1)
		{
			ClawHelperRight(0);
		}

		if (vexRT[Btn8U] == 0)
		{

			int positionOpen = 1200;

			if (abs(SensorValue[RightClawPosition]) > 1300) {
				positionOpen = 1800;
			}
			// else if (abs(SensorValue[RightClawPosition]) > 2400) {
			// 	positionOpen = 3000;
			// }

			if (vexRT[Btn6D] == 1)
			{
				ClawRightWorking = true;
				// open
				while (abs(SensorValue[RightClawPosition])<abs(positionOpen)){

					if (vexRT[Btn8L] == 1 || ClawRightWorking == false) {
						// writeDebugStreamLine("ClawRightTask) Open: Claw Timeout");

						break;
					}

					ClawHelperRight(MaxPower);
				}

				// writeDebugStreamLine("ClawRightTask) break");

				ClawRightWorking = false;

				ClawHelperRight(0);
				// if (vexRT[Btn8L] == 1)
				// {
				// 	break;
				// }


				//MoveHanging(power);
				//MoveClaw(power);
			}
			else if (vexRT[Btn6U] == 1)
			{
				// close

				if ((SensorValue[LiftPosition]) < 1500)
				{
					LiftDown(10);
				}

				ClawHelperRight(-MaxPower);
				wait1Msec(120);
				ClawHelperRight(-20);
			}
			else if (vexRT[Btn6U] == 5)
			{
				ClawRightWorking = true;
				// close
				while (abs(SensorValue[RightClawPosition])>abs(700)){


					if (vexRT[Btn8L] == 1 || ClawRightWorking == false) {
						// writeDebugStreamLine("ClawRightTask) Close: Claw Timeout");

						break;

					}

					ClawHelperRight(-MaxPower);
				}

				// writeDebugStreamLine("ClawRightTask) break");

				ClawRightWorking = false;

				ClawHelperRight(-30);
				//MoveHanging(power);
				//MoveClaw(power);
			}
		}
		else if (vexRT[Btn8U] == 1) {

			int positionOpen = 0;
			int holdPower = 0;

			if (vexRT[Btn6D] == 1) {
				positionOpen = 3500;
				holdPower = 5;
			}
			else if (vexRT[Btn5U] == 1) {
				positionOpen = 2800;
				holdPower = 0;
			}

			ClawRightWorking = true;
			// open
			while (abs(SensorValue[RightClawPosition])<abs(positionOpen)){

				if (vexRT[Btn8L] == 1 || ClawRightWorking == false) {
					// writeDebugStreamLine("ClawRightTask) Open: Claw Timeout");

					break;
				}

				int power = AdjustPowerUsingBatteryLevel(MaxPower);
				ClawHelperRight(power);
			}

			// writeDebugStreamLine("ClawRightTask) break");

			ClawRightWorking = false;

			ClawHelperRight(holdPower);
		}
	}
}


void OpenClaw(int power)
{
	ClawHelper(power);
}

void CloseClaw(int power)
{
	ClawHelper(-power);
}

void StopClaw()
{
	ClawHelper(0);
}

void ClawHelperLeft(int power)
{
	// motor[ClawRight] = power;
	motor[ClawLeft] = power;
}

void ClawHelperRight(int power)
{
	// motor[ClawRight] = power;
	motor[ClawRight] = power;
}


void ClawHelper(int power)
{
	motor[ClawRight] = power;
	motor[ClawLeft] = power;
}

// void SetKnockDown()

void SetKnockDown()
{
	int targetLift = 2250;
	int targetLeftClaw = 1500;
	int targetRightClaw = 1700;
	SetPositionHelper(true, targetLift, targetLeftClaw, targetRightClaw);
}


void SetPositionClawOnlyHelper(bool increase, int targetLeftClaw, int targetRightClaw)
{
	// Up slowly lift
	// int powerLift = 70;

	int power = (increase)? MaxPower : -MaxPower;

	while(true)
	{
		ClawHelper(power);

		if (increase) {
			if (SensorValue[LeftClawPosition] > targetLeftClaw) {
				ClawHelperLeft(0);
			}

			if (SensorValue[RightClawPosition] > targetRightClaw) {
				ClawHelperRight(0);
			}
		}
		else
		{
			if (SensorValue[LeftClawPosition] < targetLeftClaw) {
				ClawHelperLeft(0);
			}

			if (SensorValue[RightClawPosition] < targetRightClaw) {
				ClawHelperRight(0);
			}
		}

		if ((motor[ClawLeft] == 0 && motor[ClawRight] == 0 ) || vexRT[Btn8L] == 1) {
			break;
		}

	}


}

void SetPositionHelper(bool increase, int targetLift, int targetLeftClaw, int targetRightClaw)
{
	// Up slowly lift
	// int powerLift = 70;

	int power = (increase)? MaxPower : -MaxPower;

	while(true)
	{
		ClawHelper(power);
		LiftUp(MaxPower);


		if (increase) {
			if (SensorValue[LeftClawPosition] > targetLeftClaw) {
				ClawHelperLeft(0);
			}

			if (SensorValue[RightClawPosition] > targetRightClaw) {
				ClawHelperRight(0);
			}
		}
		else
		{
			if (SensorValue[LeftClawPosition] < targetLeftClaw) {
				ClawHelperLeft(0);
			}

			if (SensorValue[RightClawPosition] < targetRightClaw) {
				ClawHelperRight(0);
			}
		}

		if (SensorValue(LiftPosition) > targetLift) {
			LiftUp(0);
		}

		if ((motor[ClawLeft] == 0 && motor[ClawRight] == 0 && motor[Lift_L1] == 0) || vexRT[Btn8L] == 1) {
			break;
		}

	}


}

task Lift()
{
	while (true)
	{
		wait1Msec(50);


		int targetPosition = 1300;

		if (SensorValue(LiftPosition) > 1000) {
			targetPosition = 2100;
		}
		if (vexRT[Btn7R] == 1)
		{
			testMode = true;
			ProgrammingSkill();
			testMode = false;

		}
		else if (vexRT[Btn8R] == 1)
		{
			// Up slowly lift
			int powerLift = 75;

			// CloseClaw(20);

			while (SensorValue(LiftPosition) < targetPosition/*&&(vexRT[Btn7U]==0)*/){
				//if (vexRT[Btn7U]==1){
				//	MoveLift(100);
				//}
				LiftUp(powerLift);

				if (vexRT[Btn8L] == 1)
				{
					break;
				}
			}

			LiftUp(20);
		}
		else if (vexRT[Btn8U] == 0)
		{
			if (vexRT[Btn7U] == 1)
			{
				Throw(3000 + 400, 2000 + 500, MaxPower);
				LiftDownAndStop_Touch_DefaultTimeout(40);
				// LiftUpAndStop(2600, 120);
			}
			else if (vexRT[Btn7D] == 1)
			{
				// Down lift
				// LiftDownAndStop(900,  40);
				LiftDownAndStop_Touch_DefaultTimeout(40);
				LiftDown(10);
			}
		}
		else if (vexRT[Btn8U] == 1){
			if (vexRT[Btn7U] == 1)
			{
				LiftUp(MaxPower);
			}
			else if (vexRT[Btn7D] == 1)
			{
				LiftDown(MaxPower);
				wait1Msec(300);
				LiftDown(70);
			}
		}
	}
}

void Throw(int distanceLift, int distanceToThrow, int power){

	// CloseClaw(10);

	while (abs(SensorValue[LiftPosition])<abs(distanceLift)){
		LiftUp(power);
		if (vexRT[Btn8L] == 1)
		{
			break;
		}

		if (abs(SensorValue[LiftPosition]) > distanceToThrow ){
			OpenClaw(100);
			// power = 0;
		}
	}


	LiftStop();

	StopClaw();

	// LiftDownAndStop(900, 40);
	LiftDownAndStop_Touch_DefaultTimeout(40);

	LiftDown(10);



	// ClawHelper(-20);
	// LiftUpNoStop(distanceLift, power); // throw
	// OpenClaw();
	// wait1Msec(300);
	// LiftStop();
	// // wait1Msec(100);
	// StopClaw();
}

void LiftUpNoStop(int distance, int power) {

	while (abs(SensorValue[LiftPosition])<abs(distance)){
		LiftUp(power);
		if (vexRT[Btn8L] == 1)
		{
			break;
		}
	}
	// MoveLift(0);
}

void LiftStop()
{
	LiftHelper(0);
}

void LiftUpAndStop(int distance, int power)
{
	while (abs(SensorValue[LiftPosition])<abs(distance)){
		LiftUp(power);
		if (vexRT[Btn8L] == 1)
		{
			break;
		}
	}
	LiftStop();
}

void LiftUp(int power)
{
	LiftHelper(power);
}

void LiftDownAndStop_Touch_DefaultTimeout(int power) {
	LiftDownAndStop_Touch(power, 3000);
}

void LiftDownAndStop_Touch(int power, int timemout) {

	long startTime = nPgmTime;

	while (SensorValue[LiftTouch] == 0){

		// writeDebugStreamLine("LiftDownAndStop_Touch) LiftPosition: %d Touch: %d", abs(SensorValue[LiftPosition]), SensorValue[LiftTouch]);

		LiftDown(power);
		if (vexRT[Btn8L] == 1 || (nPgmTime - startTime) > timemout)
		{
			break;
		}
	}

	if (SensorValue[LiftTouch] == 1){
		// writeDebugStreamLine("LiftDownAndStop_Touch) Touched");
		writeDebugStreamLine("LiftDownAndStop_Touch) LiftPosition: %d Touch: %d", abs(SensorValue[LiftPosition]), SensorValue[LiftTouch]);
	}

	LiftStop();
}

void LiftDownAndStop(int distance, int power) {

	while (abs(SensorValue[LiftPosition])>abs(distance)){

		// writeDebugStreamLine("LiftDownAndStop) LiftPosition: %d", SensorValue[LiftPosition]);

		LiftDown(power);
		if (vexRT[Btn8L] == 1)
		{
			break;
		}
	}
	LiftStop();
}

void LiftDown(int power)
{
	LiftHelper(-power);
}

void LiftHelper(int power)
{
	motor[Lift_L1] = power;
	motor[Lift_L2] = power;
	motor[Lift_R1] = power;
	motor[Lift_R2] = power;
}

int AdjustPowerUsingBatteryLevel(int originalPower)
{
	float batteryLevel = nImmediateBatteryLevel;
	float batteryOffset =	7000 / batteryLevel;
	int adjustedPower = originalPower * batteryOffset;
	//  writeDebugStreamLine("(AjustBattery) BatterLevel: %d - OriginalPower: %d - WantedPower: %d", AdjustBatteryLevel, OriginalPower, WantedPower);
	return adjustedPower;
}

int AdjustPowerUsingExternalBatteryLevel(int originalPower)
{
	float batteryLevel = SensorValue[ExternalBatteryValue] * 3.57;

	float batteryOffset =	7000 / batteryLevel;
	int adjustedPower = originalPower * batteryOffset;
	//  writeDebugStreamLine("(AjustBattery) BatterLevel: %d - OriginalPower: %d - WantedPower: %d", AdjustBatteryLevel, OriginalPower, WantedPower);
	return adjustedPower;
}


task usercontrol()
{
	// User control code here, inside the loop

	startTask(StopAll);
	startTask(ClawLeftControl);
	startTask(ClawRightControl);
	startTask(ClawLeftTask);
	startTask(ClawRightTask);
	startTask(Lift);
	startTask(Move);
	startTask(Hang);
	while (true)
	{
		// This is the main execution loop for the user control program.
		// Each time through the loop your program should update motor + servo
		// values based on feedback from the joysticks.

		// ........................................................................
		// Insert user code here. This is where you use the joystick values to
		// update your motors, etc.
		// ........................................................................


	}
}
